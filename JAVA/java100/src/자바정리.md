# 자바 개념 정리

## Part3

### 1. 메서드란 무엇인가?

- 메서드는 다른 언어에서의 함수와 마찬가지로 어떤 특정한 동작이나 처리를 하도록 만들어진코드 단위이다
- 반복적인 작업을 처리해야 하는 경우 메서드로 만들어놓으면 이후에 필요할 때 다시 재사용할 수 있어서 아주 유용하다
- 메서드는 호출시 어떤 결과를 반환하기도 하지만, 결과를 반환하지 않는 메서드도 있다
- 메서드는 호출시 어떤 인자 값들을 넘겨서 호출하는 경우도 있지만, 인자 값 없이 호출하는 경우도 있다

### 2. 메서드 종류 ⇒ 크게 4가지 유형

1. 반환값 X, 받는 인자값 X
2. 반환값 X, 받는 인자값 O

   ⇒메서드가 받는 인자값이 있다는 것은 호출부에서 파라미터 값을 넘긴다는 뜻

3. 반환값 O, 받는 인자값 X

   ⇒반환값이 있다는 것은 메서드(함수) 호출에 따른 리턴값이 있는 것이므로 호출시 리턴값을 받는 변수를 정의한다

4. 반환값 O, 받는 인자값 O

### 3. 배열 값 출력하는 2가지 방법

1. 반복문
2. java.util.Arrays의 ********Arrays.toString(arr)

   Arrays.toString() 메소드는 파라미터로 배열을 입력 받아서 배열에 정의된 값들을 문자열 형태로 만들어서 리턴해 준다

### 참조 타입

- 기본 타입:
    - **byte, short, char, int, long, float, double, boolean 타입**을 말하며 이들 타입의 변수에는 **값 자체가 저장**된다
- 참조 타입
    - 기본 타입일 제외한 **배열, 열거, 클래스, 인터페이스 등**을 말한다
    - 참조 타입의 변수에는 **객체의 번지**가 저장된다
    - 번지로 객체를 참조한다는 의미에서 참조 타입이라고 함
- 메모리 사용 영역
    - JVM은 운영체제에서 할당받은 메모리 영역을 메소드 영역, 힙 영역, 스택 영역으로 구분해서 사용한다
    - 메소드 영역에는 정적 필드, 상수, 메소드 코드, 생성자 코드가 위치하며, 힙 영역에는 객체가 생성된다 그리고 스택 영역에는 변수가 생성된다
- 번지 비교
    - 비교연산자(==, !=)가 기본 타입에서 사용되면 값을 비교하지만, 참조 타입에서 사용되면 번지를 비교함
    - ==이 true가 나오면 같은 객체를 참조한다는 뜻이고 false가 나오면 다른 객체를 참조한다는 뜻
- null
    - 참조 타입 변수는 객체를 참조하지 않는다는 뜻으로 null값을 가질 수 있다
    - null값도 초기값으로 사용할 수 있기 때문에 null로 초기화된 참조 변수는 스택 여역에 생성된다
- NullPointerException
    - 참조 변수가 null을 가지고 있을 경우에는, 참조 객체가 없으므로 참조 변수를 통해 객체르 사용할 수 없다
    - 만약 null인 참조 변수를 통해 있지도 않은 객체의 필드나 메소드를 사용하면 NullPointerException이 발생한다

---

## 클래스

**1. 클래스란?**

- 클래스란 객체(또는 인스턴스)를 생성하는 하나의 공장(=틀,프레임,템플릿)이다
- 예) 시골 허허벌판에 농기계를 만들어내는 공장(Class)이 들어섰고, 농부들이 주문을 넣으면 농기계가 만들어져 나온다 -->그게 바로 "객체"(or 인스턴스)
- 내가 만들고자 하는 것을 클래스로 만들어낼 수 있다
    - 자동차 클래스(공장), AI 로봇 클래스(공장) ...

**2. 클래스 공장을 통해서 객체를 어떻게 만들어낼까?**

- 객체를 만들때 크게 "특징"과 "동작"으로 구분한 다양한 요구사항들을 공장(클래스)에다 주문한다
    - 빨간(특징) 자동차, 빠른(동작) 자동차   
      → 클래스는 이렇게 만들고자 하는 객체의 "특징"과 "동작"에 많은 시간을 들이고 집중하면서 **설계**를 하게 된다

**3. 위 사항들을 조금 어려운말로 정의해본다면?**

- __객체의 특징__ --> 속성(attribute)
- __객체의 동작__ --> 메서드(method) -->함수와 거의 동일
- 참고로, 파이썬에서는 일반적으로 함수라는 표현을 쓰지만, 클래스 내에서의 함수는 메서드라고 부른다. 거의 함수와 동일하다

### 클래스에서 생성자의 개념과 역할, 특징

1. 생성자(Constructor)  
   (== 공장에 제출할 주문서)

- 생성자는 new키워드로 클래스의 __객체(또는 인스턴스)가 생성될 때__ 제일 먼저 자동적으로 호출되는 메서드
- 따라서, **객체의 초깃값을 설정**하는 등의 용도로 많이 사용된다
- 생성자명은 클래스명과 동일하게 만든다
- 생성자는 리턴되는 반환값이 없다--> 객체가 생성될 때 제일 먼저 **호출만** 된다(=호출만 가능)
- 생성자는 오버로딩이 가능하다
- default생성자라는게 있다 -->만약 클래스내에 생성자가 없다면 default 생성자가 자동 호출된다 --> 이것은 클래스명과 동일하고, 받는 인자값 x

2. 생성자 위치

- 보통 속성과 메서드 사이에 기술
- 생성자도 메서드이므로 메서드 그룹에 속하는데 보통 제일 상단에 위치

1. 예제
    ```
   class Person{
        //1. 속성(attribute)
        int age;
        String name;
        //2. 생성자(Constructor)
        Person(){}   //객체가 생성될 때 자동으로 호출되는 메서드 
        //3. 메서드(Method)
        void move(){
            System.out.println("Person is moving");
        }
   }

### 클래스에서 상속에 대한 개념과 특징

1. 상속(Inheritance)이란?

- 부모 클래스가 가지고 있는 속성(변수)들과 동작/기능(메서드)들을 그대로 물려받아 새로운 클래스를 만드는 것
- 상속을 활용하면 물려받은 것들은 그대로 쓰면 되고, 거기에 덧붙여 새로운 것만 만들면 되므로 그만큼 노력과 시간이 세이브된다
- 이떄, 물려받게 되는 원본 클래스를 부모 클래스(Parent class) 또는 슈퍼 클래스(Super class)라고 부름
- 상속받아 새롭게 만들어진 클래스는 자식 클래스(Child class) 또는 서브/하위 클래스(Sub class)라고 부름
- 또 다른 표현으로는 기초/기반클래스(Base class) - 파생 클래스(Derived class)라고도 부름

2. 상속의 장점

- 재활용성!
    - 완전히 새로운 것을 만드는 것이 아니라 기존 부모로부터 상속을 받아 필요한 것만 추가로 더해서 만드는 것
    - 부모 클래스에 정의되어져 있는 멤버 필드(변수)나 메서드들을 그대로 상속받아 사용하면 된다
    - 상속받은 메서드라 해도 필요에 따라서 자식 클래스에서 용도를 변경해 사용하는 것도 가능

3. 상속의 사용

- 기존 부모 클래스를 확장한다는 개념 --> extends 키워드 사용
- 부모 클래스의 멤버 필드, 메서드는 상속이 가능하나 생성자는 상속이 안된다
- 부모 클래스의 접근 제한자 private인 경우에는 아무리 자식 클래스가 상속을 받았다 하더라도 접근 불가능

## 추상 클래스와 추상 메서드

## 인터페이스란?

- 사전적 의미: 결합부, 접속기 --> 사용자간 또는 컴퓨터간 통신이 가능하도록 해주는 디바이스나 프로그램
- 큰 틀에서 본다면 자바에서 인터페이스 개념도 사전적 의미와 비슷하다

### 추상 클래스 vs 인터페이스

- 추상 클래스와 거의 비슷 --> 그러나 그 추상화 정도가 더 높다(더 엄격하다) 따라서, 인터페이스에서는 일반 멤버 필드(변수)를 가질 수 없다
- 이러한 점들이 추상 클래스와 인터페이스간 가장 큰 차이점 중 하나이다

### 자바에서의 인터페이스 문법?

- 표준화 및 규격을 인터페이스로 제공
- 따라서 어떤 클래스가 해당 인터페이스를 사용(상속)한다면 인터페이스에 선언되어져 있는 메서드를 구현해야 한다
- 인터페이스는 class 키워드를 사용하지 않고 별도의 interface 키워드를 사용
- class --> extends // interface --> extends(x), implement(o)
- 추상 클래스와 같이 메서드의 구체적인 내용은 기술되어져 있지 않으므로 인터페이스를 상속받은 클래스에서 재정의(오버라이딩)하여 사용해야 한다

### 상속 vs 구현

- 클래스와 인터페이스 이 둘의 가장 큰 차이점 중 하나는 "상속"이다
- 자바에서 클래스는 "단일 상속"만 가능하지만 ,인터페이스는 "다중 상속"이 가능하다
- 그러나 인터페이스에서는 extends 표현을 쓰지않고 "구현"의 의미를 강조하는 implements 키워드를 사용하여 다중 상속을 구현한다

### 장점

- 인터페이스를 이용하면 메소드의 추상적인 '선언'과 그 메서드들을 구체적인 '구현'부분을 분리시킬 수 있다
- 하청을 주는 대기업(값)은 하청업체(을)에 인터페이스만 제공 --> 각 하청업체(을)들이 이를 준수하여(=상속 받아)개발
- 분업화된 시스템을 구축하여 "갑"과 "을"이 독립적으로 프로젝트 개발을 해나갈 수 있다 --> 매우 큰 장점

### 우선 순위(extends vs implements)

- 상속을 받는 extends 키워드와 구현을 하는 implements 키워드가 동시에 쓰일때 --> extends키워드가 항상 먼저 쓰인다
- 예) class Student extends Person implements A,B

## 다형성(polymorphism)

[1]다형성이란?

- 다형성이란 다양한 형태 또는 특성 가진다는 의미
- 자바와 같은 객체 지향 언어에서의 의미는 부모 클래스를 상속받은 자식 클래스의 인스턴스가 부모의 객체로도 사용되고, 뿐만 아니라, 자식 클래스의 객체로도 사용될 수 있는 다양한 상황을 의미한다

[2]예시

- 부모 클래스 Bird가 있고, 이를 상속받은 자식 클래스 Parrot이 있다고 가정하자
- 이때, "앵무새가 말을 하네.."사람들이 이렇게 말할 수 있음
- 그런데 앵무새는 새이기 때문에 "새가 말을 하네.." 이렇게도 말할 수 있다

[3]결론

정리하면 하위 클래스의 인스턴스(객체)는 보다 위인 상위 클래스의 인스턴스(객체)로도 사용될 수 있다. 그런데 그 반대는 안된다 왜냐하면 "앵무새"는 분명 그 상위인 "새"라고 말할 수 있지만, 새는 종류가 많기
때문에 모든 새가 앵무새가 아니기 때문이다 따라서, 상위(부모)클래스의 인스턴스(객체)는 하위(자식) 클래스의 인스턴스(객체)로 사용될 수 없다

예)  
Bird aaa = new Parrot(); ----> O Parrot bbb = new Bird(); ----> X

```java

class Person {
    String str1 = "난 부모 클래스";

    void method1() {
        System.out.println("에이");
    }

    void ppp() {
        System.out.println("ppp");
    }
}

class Student extends Person8 {
    String str2 = "난 자식 클래스";

    @Override
    void method1() {
        System.out.println("오버라이딩-aaa");
    }

    void ppp() {
        System.out.println("sss");
    }
}

public class Java100_ex10 {
    public static void main(String[] args) {
        //객체 생성--> 부모+자식 클래스의 모든 자원을 다 쓸 수 있다
        Student s1 = new Student();
        System.out.println(s1.str1);
        System.out.println(s1.str2);

        //자식(하위) 클래스로 객체를 만들면서 타입은 부모(상위) 타입으로 쓰는 것이 가능 --> 다형성
        //객체 생성 --> 범위는 부모의 자원만을 쓸 수 있다
        Person s2 = new Student();
        //만약 자식의 메서드를 바로 호출하고 싶다면? --> 캐스트 하기
        ((Student3) s2).sss();
        
        Person p1 = new Person();

        //상위(부모) 클래스로 객체를 생성하면서 타입은 하위(자식)타입을 쓰는 경우 
        //Student3 p2 =new Person8(); --> Err
    }
}

```